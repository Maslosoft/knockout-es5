# Lazily created by `getSubscribableForArray` below. Has to be created lazily because the
# WeakMap factory isn't available until the module has finished loading (may be async).
arraySubscribablesMap = undefined
# Array handling
# --------------
#
# Arrays are special, because unlike other property types, they have standard mutator functions
# (`push`/`pop`/`splice`/etc.) and it's desirable to trigger a change notification whenever one of
# those mutator functions is invoked.
#
# Traditionally, Knockout handles this by putting special versions of `push`/`pop`/etc. on observable
# arrays that mutate the underlying array and then trigger a notification. That approach doesn't
# work for Knockout-ES5 because properties now return the underlying arrays, so the mutator runs
# in the context of the underlying array, not any particular observable:
#
#     // Operates on the underlying array value
#     myModel.someCollection.push('New value');
#
# To solve this, Knockout-ES5 detects array values, and modifies them as follows:
#  1. Associates a hidden subscribable with each array instance that it encounters
#  2. Intercepts standard mutators (`push`/`pop`/etc.) and makes them trigger the subscribable
# Then, for model properties whose values are arrays, the property's underlying observable
# subscribes to the array subscribable, so it can trigger a change notification after mutation.
# Given an observable that underlies a model property, watch for any array value that might
# be assigned as the property value, and hook into its change events

notifyWhenPresentOrFutureArrayValuesMutate = (ko, observable) ->
  watchingArraySubscription = null
  ko.computed ->
    # Unsubscribe to any earlier array instance
    if watchingArraySubscription
      watchingArraySubscription.dispose()
      watchingArraySubscription = null
    # Subscribe to the new array instance
    newArrayInstance = observable()
    if newArrayInstance instanceof Array
      watchingArraySubscription = startWatchingArrayInstance(ko, observable, newArrayInstance)
    return
  return

# Listens for array mutations, and when they happen, cause the observable to fire notifications.
# This is used to make model properties of type array fire notifications when the array changes.
# Returns a subscribable that can later be disposed.

startWatchingArrayInstance = (ko, observable, arrayInstance) ->
  subscribable = getSubscribableForArray(ko, arrayInstance)
  subscribable.subscribe observable

# Gets or creates a subscribable that fires after each array mutation

getSubscribableForArray = (ko, arrayInstance) ->
  if !arraySubscribablesMap
    arraySubscribablesMap = weakMapFactory()
  subscribable = arraySubscribablesMap.get(arrayInstance)
  if !subscribable
    subscribable = new (ko.subscribable)
    arraySubscribablesMap.set arrayInstance, subscribable
    notificationPauseSignal = {}
    wrapStandardArrayMutators arrayInstance, subscribable, notificationPauseSignal
    addKnockoutArrayMutators ko, arrayInstance, subscribable, notificationPauseSignal
  subscribable

# ---
# generated by js2coffee 2.2.0

# After each array mutation, fires a notification on the given subscribable

wrapStandardArrayMutators = (arrayInstance, subscribable, notificationPauseSignal) ->
  [
    'pop'
    'push'
    'reverse'
    'shift'
    'sort'
    'splice'
    'unshift'
  ].forEach (fnName) ->
    origMutator = arrayInstance[fnName]

    arrayInstance[fnName] = ->
      result = origMutator.apply(this, arguments)
      if notificationPauseSignal.pause != true
        subscribable.notifySubscribers this
      result

    return
  return


# Adds Knockout's additional array mutation functions to the array

addKnockoutArrayMutators = (ko, arrayInstance, subscribable, notificationPauseSignal) ->
  [
    'remove'
    'removeAll'
    'destroy'
    'destroyAll'
    'replace'
  ].forEach (fnName) ->
    try
      # Make it a non-enumerable property for consistency with standard Array functions
      Object.defineProperty arrayInstance, fnName,
        enumerable: false
        value: ->
          result = undefined
          # These additional array mutators are built using the underlying push/pop/etc.
          # mutators, which are wrapped to trigger notifications. But we don't want to
          # trigger multiple notifications, so pause the push/pop/etc. wrappers and
          # delivery only one notification at the end of the process.
          notificationPauseSignal.pause = true
          try
            # Creates a temporary observableArray that can perform the operation.
            result = ko.observableArray.fn[fnName].apply(ko.observableArray(arrayInstance), arguments)
				# `finally` workaround
            notificationPauseSignal.pause = false
          catch e
				# `finally` workaround
            notificationPauseSignal.pause = false
          subscribable.notifySubscribers arrayInstance
          result
    catch e
      # Skip existing
    return
  return

# ---
# generated by js2coffee 2.2.0
